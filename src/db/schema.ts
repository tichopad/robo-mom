import { relations, sql } from "drizzle-orm";
import {
	integer,
	json,
	pgTable,
	text,
	unique,
	vector,
} from "drizzle-orm/pg-core";
import { createInsertSchema, createSelectSchema } from "drizzle-zod";
import { z } from "zod";

/**
 * Notes table schema
 *
 * Contains all the notes in the user's knowledge base
 */
export const notesTable = pgTable("notes", {
	id: text().primaryKey().notNull().default(sql`gen_random_uuid()`),
	filename: text().notNull(),
	chunk_index: integer().notNull(),
	text: text().notNull(),
	text_vector: vector({ dimensions: 768 }),
	filename_vector: vector({ dimensions: 768 }),
	// SHA256 checksum of the original file content
	checksum: text().notNull(),
	// Frontmatter metadata parsed from each Markdown file
	frontmatter_attributes: json(
		"frontmatter_attributes",
	).$type<FrontmatterAttributes>(),
});

/** Type for a row in the notes table */
export type Note = typeof notesTable.$inferSelect;
/** Type for inserting a new note */
export type NewNote = typeof notesTable.$inferInsert;
/** Type for frontmatter attributes in a note record */
export type FrontmatterAttributes = z.infer<typeof noteJsonFieldsSchemas.frontmatter_attributes>;

// Schemas used for JSON fields in notesTable
const noteJsonFieldsSchemas = {
	frontmatter_attributes: z.record(z.string(), z.unknown()),
};

/** Validation schema for selecting notes */
export const noteSchema = createSelectSchema(notesTable, noteJsonFieldsSchemas);
export const newNoteSchema = createInsertSchema(
	notesTable,
	noteJsonFieldsSchemas,
);

/**
 * Conversations table schema
 *
 * Tracks each LLM conversation session
 */
export const conversationsTable = pgTable("conversations", {
	/**
	 * UUID string, primary key, generated by default using crypto.randomUUID
	 * Note: The default value should be set at the application layer when inserting, as Drizzle/SQL cannot call JS functions for defaults.
	 */
	id: text().primaryKey().notNull().default(sql`gen_random_uuid()`),
	created_at: text().notNull().default("now()"),
	ended_at: text(), // nullable timestamp
	status: text().notNull().default("active"),
});
export const conversationsRelations = relations(
	conversationsTable,
	({ many }) => ({
		messages: many(messagesTable),
	}),
);

/** Type for a row in the conversations table */
export type Conversation = typeof conversationsTable.$inferSelect;
/** Type for inserting a new conversation */
export type NewConversation = typeof conversationsTable.$inferInsert;

/**
 * Messages table schema
 *
 * Stores all user and assistant messages for analytics
 */
export const messagesTable = pgTable(
	"messages",
	{
		id: text().primaryKey().notNull().default(sql`gen_random_uuid()`),
		conversation_id: text()
			.notNull()
			.references(() => conversationsTable.id, {
				onDelete: "cascade",
			}),
		message_index: integer().notNull(),
		role: text().notNull(), // "user" | "assistant"
		content: text().notNull(),
		created_at: text().notNull().default("now()"),
		request_id: text(), // nullable, for assistant messages
		input_prompt: text(), // nullable, for assistant messages
		tools_used: json("tools_used").$type<ToolCall[]>(),
		model_config: json("model_config").$type<ModelConfig>(),
		sdk_config: json("sdk_config").$type<SdkConfig>(),
		tokens_used: json("tokens_used").$type<TokensUsed>(),
		timing_data: json("timing_data").$type<TimingData>(),
	},
	(t) => [unique().on(t.conversation_id, t.message_index)],
);
export const messagesRelations = relations(messagesTable, ({ one }) => ({
	conversation: one(conversationsTable, {
		fields: [messagesTable.conversation_id],
		references: [conversationsTable.id],
	}),
}));

// Schemas used for JSON fields in messagesTable
const messageJsonFieldsSchemas = {
	tools_used: z.array(
		z.object({
			name: z.string(),
			arguments: z.record(z.string(), z.unknown()),
		}),
	),
	model_config: z.record(z.string(), z.unknown()),
	sdk_config: z.record(z.string(), z.unknown()),
	tokens_used: z.object({
		prompt: z.number(),
		completion: z.number(),
		total: z.number(),
	}),
	timing_data: z.object({
		start: z.string(),
		end: z.string(),
		durationMs: z.number(),
	}),
};
/** Validation schema for selecting messages */
export const messageSchema = createSelectSchema(
	messagesTable,
	messageJsonFieldsSchemas,
);
export const newMessageSchema = createInsertSchema(
	messagesTable,
	messageJsonFieldsSchemas,
);

/** Type for a row in the messages table */
export type Message = typeof messagesTable.$inferSelect;
/** Type for inserting a new message */
export type NewMessage = typeof messagesTable.$inferInsert;
/** Type for a stored tool call in a message record */
export type ToolCall = z.infer<typeof messageJsonFieldsSchemas.tools_used>;
/** Type for tokens used in a message record */
export type TokensUsed = z.infer<typeof messageJsonFieldsSchemas.tokens_used>;
/** Type for timing data in a message record */
export type TimingData = z.infer<typeof messageJsonFieldsSchemas.timing_data>;
/** Type for model config in a message record */
export type ModelConfig = z.infer<typeof messageJsonFieldsSchemas.model_config>;
/** Type for SDK config in a message record */
export type SdkConfig = z.infer<typeof messageJsonFieldsSchemas.sdk_config>;
